<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Grid Maze</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #121212; /* Dark background */
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }

        #maze-container {
            display: grid;
            grid-template-columns: repeat(10, 30px); /* 10x10 grid, 30px cells */
            grid-template-rows: repeat(10, 30px);
            border: 4px solid #4CAF50; /* Prominent green border for the maze */
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5); /* Green glow effect */
            background-color: #222;  /* Slightly lighter dark for the maze interior */
        }

        .cell {
            width: 30px;
            height: 30px;
            box-sizing: border-box; /* Include padding and border in element's total width and height */
            background-color: #222; /* Cell background */
        }

        .wall-top {
            border-top: 2px solid #4CAF50;  /* Green walls */
        }

        .wall-right {
            border-right: 2px solid #4CAF50;
        }

        .wall-bottom {
            border-bottom: 2px solid #4CAF50;
        }

        .wall-left {
            border-left: 2px solid #4CAF50;
        }

        .player {
            background-color: #f44336; /* Red player */
            border-radius: 50%; /* Circular player */
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.7); /* Red glow */
            transition: transform 0.1s ease-out; /* Smooth movement */
           /* z-index: 2;  Keep the player above the walls */
        }

        .visited {
            /* Subtle visual indication of visited cells (optional) */
            background-color: #2a2a2a;
        }
        .end {
            background-color: #FFD700; /* Gold color for the end */
            border-radius: 5px; /* Slightly rounded corners */
           box-shadow: 0 0 10px rgba(255, 215, 0, 0.7); /* Gold glow */
        }

        /* Controls (optional, but good for testing/demo) */
        #controls {
            margin-top: 20px;
            text-align: center;
            color: white;
        }
        #controls button{
            margin-left: 10px;
        }
         #message {
            position: absolute;  /* Position it over the maze */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000000; /* Text shadow for readability */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
            padding: 20px;
            border-radius: 10px;
            display: none;  /* Hidden by default */
            z-index: 10;  /* Ensure it's above everything */
        }


    </style>
</head>
<body>

    <div id="maze-container"></div>
    <div id="message"></div>
    <div id="controls">
        <button id="reset-button">Reset Maze</button>
    </div>

    <script>
        const mazeContainer = document.getElementById('maze-container');
        const resetButton = document.getElementById('reset-button');
        const messageDiv = document.getElementById('message');
        let playerRow, playerCol;
        let maze;
        let endRow, endCol;



        function generateMaze(rows, cols) {
            // 1. Create grid of cells, all initially with walls.
            const grid = Array(rows).fill(null).map(() => Array(cols).fill(null).map(() => ({
                top: true,
                right: true,
                bottom: true,
                left: true,
                visited: false
            })));

            // 2. Recursive backtracking algorithm.
            function carvePath(row, col) {
                grid[row][col].visited = true;

                const directions = [
                    { dr: -1, dc: 0, wall: 'top', opposite: 'bottom' },  // Up
                    { dr: 0, dc: 1, wall: 'right', opposite: 'left' },   // Right
                    { dr: 1, dc: 0, wall: 'bottom', opposite: 'top' },  // Down
                    { dr: 0, dc: -1, wall: 'left', opposite: 'right' }   // Left
                ];

                directions.sort(() => Math.random() - 0.5); // Shuffle directions

                for (const dir of directions) {
                    const newRow = row + dir.dr;
                    const newCol = col + dir.dc;

                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !grid[newRow][newCol].visited) {
                        grid[row][col][dir.wall] = false;        // Remove current cell's wall
                        grid[newRow][newCol][dir.opposite] = false; // Remove neighbor's opposite wall
                        carvePath(newRow, newCol);              // Recur from the new cell
                    }
                }
            }

            // 3. Start carving from a random cell (e.g., top-left).
             carvePath(0, 0);

            return grid;
        }


        function renderMaze(maze) {
            mazeContainer.innerHTML = ''; // Clear previous maze

            for (let row = 0; row < maze.length; row++) {
                for (let col = 0; col < maze[row].length; col++) {
                    const cell = maze[row][col];
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('cell');
                    cellDiv.dataset.row = row;
                    cellDiv.dataset.col = col;

                    if (cell.top) cellDiv.classList.add('wall-top');
                    if (cell.right) cellDiv.classList.add('wall-right');
                    if (cell.bottom) cellDiv.classList.add('wall-bottom');
                    if (cell.left) cellDiv.classList.add('wall-left');
                    if(cell.visited) cellDiv.classList.add("visited");

                    mazeContainer.appendChild(cellDiv);
                }
            }
            //Create and position the player.  Important to do this *after* the maze cells.
            createPlayer();
            createEnd();
        }
        function createPlayer() {
                const playerDiv = document.createElement('div');
                playerDiv.classList.add('player');
                mazeContainer.appendChild(playerDiv);

                // Start the player at the top-left (or a random open cell)
                playerRow = 0;
                playerCol = 0;

                updatePlayerPosition();
            }

            function updatePlayerPosition() {
                const playerDiv = document.querySelector('.player');
                const cellWidth = 30; // Match CSS cell size
                const cellHeight = 30;

                // Use transform for smoother movement.
                playerDiv.style.transform = `translate(${playerCol * cellWidth}px, ${playerRow * cellHeight}px)`;
                 document.querySelector(`.cell[data-row="${playerRow}"][data-col="${playerCol}"]`).classList.add("visited");

            }

            function createEnd(){
                endRow = maze.length - 1;
                endCol = maze[0].length-1;
                const endCell = document.querySelector(`.cell[data-row="${endRow}"][data-col="${endCol}"]`);
                endCell.classList.add("end");

            }


        function handleKeyPress(event) {
            let newRow = playerRow;
            let newCol = playerCol;
            let moved = false;

            switch (event.key) {
                case 'ArrowUp':
                    if (!maze[playerRow][playerCol].top) {
                        newRow--;
                        moved = true;
                    }
                    break;
                case 'ArrowDown':
                    if (!maze[playerRow][playerCol].bottom) {
                        newRow++;
                         moved = true;
                    }
                    break;
                case 'ArrowLeft':
                    if (!maze[playerRow][playerCol].left) {
                        newCol--;
                        moved = true;
                    }
                    break;
                case 'ArrowRight':
                    if (!maze[playerRow][playerCol].right) {
                        newCol++;
                        moved = true;
                    }
                    break;
            }


             if (moved) {
                playerRow = newRow;
                playerCol = newCol;
                updatePlayerPosition();
                  if (playerRow === endRow && playerCol === endCol) {
                    showWinMessage();
                 }

            }
        }
         function showWinMessage() {
            messageDiv.textContent = "Congratulations! You solved the maze!";
            messageDiv.style.display = "block";
        }

        function initGame() {
            maze = generateMaze(10, 10);
            renderMaze(maze);
             messageDiv.style.display = "none"; // Hide message on reset

        }



        // Event listeners
        document.addEventListener('keydown', handleKeyPress);
        resetButton.addEventListener('click', initGame);

        // Initial maze generation
        initGame();

    </script>
</body>
</html>
